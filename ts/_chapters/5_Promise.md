# 5. Promise и магия async/await

Помните времена, когда асинхронные функции вызывались таким вот образом?

---

```typescript

function callbackHellExample(cb: Function) {
  fs.readFile('file.txt', function (err, data) {
      if (err) throw err;
      fs.writeFile('file.txt', '', function (err) {
          if (err) throw err;
          
          cb();
      });
  });
}

```

---

Этому явлению придумали устрашающее название `Callback Hell`.

В приведённом выше примере это не так страшно, т.к. здесь последовательно вызываются всего две асинхронные функции. Но что если нам необходимо последовательно вызвать десять, двадцать, 100500 асинхронных функций? Тогда наш код может превратиться в лестницу, сопоставимую с лестницей на Медео. Такой код - это ничто иное, как проявление жестокости по отношению к программистам.

Поэтому и были введены Промисы. Ну, не только поэтому.

Технология сама по себе не нова: Промисы уже давно есть в Ruby, C# (там это называется Task) и, как я полагаю, много где ещё.

Теперь вышепредставленный код мы можем описать таким образом (вообразим, что наша библиотека `fs` умеет работать с Промисами):

```typescript
function callbackHellExample(cb: Function) {
  fs.readFile('file.txt').then(function (data) {
      fs.writeFile('file.txt', '').then(function () {

      });
  });
}
```

Не сильно помогло, да? Согласен. Однако здесь стоит отметить, что теперь мы имеем дело с объектом, которым намного удобнее манипулировать. Ну и наряду с появлением Промисов был введён стандарт `async`/`await` (который также перекочевал в JS из Ruby и C#).

Поэтому теперь мы можем делать вот так:

```typescript
async function myAsyncAwaitFunction(): Promise<void> {
  let data = await fs.readFile('file.txt');
  await fs.writeFile('file.txt', '');
}
```

Объект Promise по умолчанию содержит всего два метода: `.then()` и `.catch()`.

Метод `.then()` принимает функцию, которая выполнится по возвращении ответа.
Метод `.catch()` принимает функцию, которая выполнится при выбросе ошибки во время выполнения асинхронной операции.

Стоит отметить, что обе функции всегда возвращают только один аргумент, либо пустоту. Нельзя вернуть более одного аргумента, как это было в случае устаревших `(err, arg1, arg2, ..., argN) => `. Тогда это было допустимо. Ну, если уж так сильно хочется, можно собрать массив вида `[arg1, arg2, ..., argN]`, вернуть его и разобрать на выходе.

Небольшая вкусняшка: когда мы используем подход `async` / `await`, для отлова ошибок мы можем использовать привычный `try`/`catch`:

```typescript
async function myAsyncAwaitFunction(): Promise<void> {
  try {
      let data = await fs.readFile('file.txt');
      await fs.writeFile('file.txt', '');
  } catch (err) {
      // ...
  }
}
```

То же самое касается циклов.

Вариант с коллбэками был абсолютно непригоден для использования наряду с циклами - "зациклить" асинхронные функции старого формата было попросту невозможно, не прибегая к сторонним модулям. Здесь же мы получаем возможность использовать `await something();` внутри цикла и всё будет прекрасно работать.

```typescript
async function myAsyncAwaitFunction(): Promise<void> {
  for (let i = 0; i < 10; i++) {
      let data = await fs.readFile(`file_${i}.txt`);
      await fs.writeFile(`file_${i}.txt`, '');
  }
}
```

Если хотите сохранить свой спокойный сон, не пытайтесь смотреть на то, что из этого получается на выходе после компиляции (Я предупреждал).

`TODO: Добавить пример с наследованием от Promise`

`TODO: Добавить пример - как сделать Promise-функцию из асинхронной`
