# 0. Ссылки

* https://www.typescriptlang.org/
* https://www.typescriptlang.org/play
* https://github.com/microsoft/TypeScript/
* https://twitter.com/TypeScript

# 1. Введение в Typescript

Я изучаю TS с 2013 года, в то время как первый его релиз был за год до этого. Как сейчас помню, на тот момент это было в новинку, из-за чего не все понимали цель его создания. Ну типы, ну дженерики, окей, а дальше что?.

Первые пару недель изучения я тоже с трудом мог ответить себе на многие вопросы, однако вдоволь наигравшись с [онлайн-компилятором](http://www.typescriptlang.org/play/index.html) я быстро обрёл понимание сути (достаточно скомпилировать, например, строку `async function a() {}`).

Теперь же, набравшись опыта, я при любой возможности беру TS в тех случаях, когда это допустимо. Например, если мне нужно разработать маленькую консольку, которая будет складывать два числа, то TS очевидно будет избыточным (разве что если есть уже готовый рабочий boilerplate). Но если же я пишу проект с перспективой разрастания во что-то масштабное, то TS для меня будет лучшим выбором как на фронтенде, так и на бэкенде, если позволяет ситуация. (TypeScript === JavaScript that scales.)

## Немного истории
TS родился прямо перед концом света в 2012 году и, как и мы все, успешно его пережил.
TS принято считать младшим братом `C#` и далёким родственником `Delphi`. Все три языка были разработаны или первично реализованы [вот этим дядькой](https://ru.wikipedia.org/wiki/%D0%A5%D0%B5%D0%B9%D0%BB%D1%81%D0%B1%D0%B5%D1%80%D0%B3,_%D0%90%D0%BD%D0%B4%D0%B5%D1%80%D1%81).

---

<center>
<img src="_media\Anders_Hejlsberg.jpg" alt="drawing" width="200"/>

**Андерс Хейлсберг** — датский инженер-программист. Создатель Turbo Pascal, Delphi, C# и TypeScript. (Фото с Википедии)
</center>


Язык прекрасно поддерживается всеми современными IDE, в числе которых `JetBrains WebStorm` и Майкрософтовский `VSCode` (недавно слушал [интересный подкаст от разработчика плагина TS для JetBrains](https://medium.com/devschacht/devschacht-61-75ac8fd58960), но вам я его не покажу.)

За 7 лет своего существования язык обзавёлся огромным сообществом и продолжает активно развиваться. 

## Интересные факты
* Компилятор TS написан на TS.
* На момент написания статьи [в репозитории компилятора](https://github.com/Microsoft/TypeScript) было реализовано [почти 65 тысяч тестов](https://travis-ci.org/Microsoft/TypeScript/jobs/508296875#L631). Это примерно на 3-4 тыс. больше, чем за год до этого. Есть с кого брать пример.



# 5. Promise и магия `async`/`await`

Помните времена, когда асинхронные функции вызывались таким вот образом?

```typescript
function callbackHellExample(cb: Function) {
    fs.readFile('file.txt', function (err, data) {
        if (err) throw err;
        fs.writeFile('file.txt', '', function (err) {
            if (err) throw err;
            
            cb();
        });
    });
}
```

Этому явлению придумали устрашающее название `Callback Hell`.

В приведённом выше примере это не так страшно, т.к. здесь последовательно вызываются всего две асинхронные функции. Но что если нам необходимо последовательно вызвать десять, двадцать, 100500 асинхронных функций? Тогда наш код может превратиться в лестницу, сопоставимую с лестницей на Медео. Такой код - это ничто иное, как проявление жестокости по отношению к программистам.

Поэтому и были введены Промисы. Ну, не только поэтому.

Технология сама по себе не нова: Промисы уже давно есть в Ruby, C# (там это называется Task) и, как я полагаю, много где ещё.

Теперь вышепредставленный код мы можем описать таким образом (вообразим, что наша библиотека `fs` умеет работать с Промисами):

```javascript
function callbackHellExample(cb: Function) {
    fs.readFile('file.txt').then(function (data) {
        fs.writeFile('file.txt', '').then(function () {

        });
    });
}
```

Не сильно помогло, да? Согласен. Однако здесь стоит отметить, что теперь мы имеем дело с объектом, которым намного удобнее манипулировать. Ну и наряду с появлением Промисов был введён стандарт `async`/`await` (который также перекочевал в JS из Ruby и C#).

Поэтому теперь мы можем делать вот так:

```typescript

async function myAsyncAwaitFunction(): Promise<void> {
    let data = await fs.readFile('file.txt');
    await fs.writeFile('file.txt', '');
}

```

Объект Promise по умолчанию содержит всего два метода: `.then()` и `.catch()`.

Метод `.then()` принимает функцию, которая выполнится по возвращении ответа.
Метод `.catch()` принимает функцию, которая выполнится при выбросе ошибки во время выполнения асинхронной операции.

Стоит отметить, что обе функции всегда возвращают только один аргумент, либо пустоту. Нельзя вернуть более одного аргумента, как это было в случае устаревших `(err, arg1, arg2, arg3, argN) => `. Тогда это было допустимо.

Небольшая вкусняшка: когда мы используем подход `async` / `await`, для отлова ошибок мы можем использовать привычный `try`/`catch`:

```typescript
async function myAsyncAwaitFunction(): Promise<void> {
    try {
        let data = await fs.readFile('file.txt');
        await fs.writeFile('file.txt', '');
    } catch (err) {
        // ...
    }
}
```

То же самое касается циклов.

Вариант с коллбэками был абсолютно непригоден для использования наряду с циклами - "зациклить" асинхронные функции старого формата было попросту невозможно, не прибегая к сторонним модулям. Здесь же мы получаем возможность использовать `await something();` внутри цикла и всё будет прекрасно работать.

```typescript
async function myAsyncAwaitFunction(): Promise<void> {
    for (let i = 0; i < 10; i++) {
        let data = await fs.readFile(`file_${i}.txt`);
        await fs.writeFile(`file_${i}.txt`, '');
    }
}
```

Если хотите сохранить свой спокойный сон, не пытайтесь смотреть на то, что из этого получается на выходе после компиляции (Я предупреждал).

`TODO: Добавить пример с наследованием от Promise`

`TODO: Добавить пример - как сделать Promise-функцию из асинхронной`

# 6. Reflect

Цитата с [MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Reflect):

> **Reflect** - это встроенный объект, который предоставляет методы для перехватывания JavaScript операций. Эти методы аналогичны методам proxy handler`ов. Reflect - это не функциональный, а простой объект, он не является сконструированным.

## Что такое emitDecoratorMetadata и при чём тут Angular?

## design:*

TODO: Рассказать об `emitDecoratorMetadata`

TODO: Рассказать о полифилле `reflect-metadata`

# 7. @декораторы 

**Декораторы** - одно из нововведений ESNext.
По сути своей декоратор - это обычная функция, которая принимает от одного до трёх аргументов (в зависимости от типа декоратора).


## Немного воображения
Возможно это не совсем удачная аналогия, но давайте представим, что класс - это новогодняя ёлка, а декораторы - это самые разные игрушки, которыми мы обвешиваем нашу ёлочку).

## Примеры
В Спецификации TS есть 4 вида декораторов, для которых прописаны тайпинги:

 * [ClassDecorator](#classdecorator)
 * [MethodDecorator](#methoddecorator)
 * [PropertyDecorator](#propertydecorator)
 * [ParameterDecorator](#parameterdecorator)

### ClassDecorator
Объявление ([lib.es5.d.ts:1379](https://github.com/Microsoft/TypeScript/blob/v3.3.1/lib/lib.es5.d.ts#L1379)):
```typescript
declare type ClassDecorator = <TFunction extends Function>(target: TFunction) => TFunction | void;
```

Из названия понятно, что этот декоратор можно вешать только на классы. В target будет передана функция-конструктор этого класса.

#### Экзампель:
```typescript

function Y(target: Function) {
    // do something
}

@Y
class X {

}

```

Аналогичный пример, только без использования декораторной функции как декоратора:
```typescript
class X {

}

Y(X);

```

### MethodDecorator
Объявление ([lib.es5.d.ts:1381](https://github.com/Microsoft/TypeScript/blob/v3.3.1/lib/lib.es5.d.ts#L1381)):
```typescript
declare type MethodDecorator = <T>(target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor<T>) => TypedPropertyDescriptor<T> | void;
```

Вот здесь чуть-чуть веселее. Эту разновидность декораторов можно вешать только на методы (присутствие тела метода обязательно, иначе это не метод, а свойство, даже если содержит в себе функцию.). В аргументы приходит следующее:

1. Если метод статический, то в `target` передаётся функция-конструктор, как в примере выше. Если же метод инстансовый, то в `target` прилетит объект-прототип (`Class.prototype`) используемого класса.
2. Во второй аргумент `propertyKey` прилетит строка с именем поля. Эта строка генерируется во время компиляции кода в JS и не страдает, например, при минификации кода.
3. Ну и в третий аргумент `descriptor` будет передан дескриптор поля с указанным методом, полученный путём вызова `Object.getOwnPropertyDescriptor(target, propertyKey)`.

#### Ехампле:
```typescript

function Y(target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor): PropertyDescriptor {
    descriptor.value = function () {
        console.log('Noooooo!');
    };

    return descriptor;
}

class X {
    @Y
    public myAwesomeMethod() {
        console.log('Luke, I\'m your father!');
    }
}

new X().myAwesomeMethod(); // Logs 'Noooooo!'
```
Данный пример показывает, как подменить ~~ребёнка в роддоме~~ метод у класса при помощи декоратора.

Ну и, конечно же, приведу пример кода  без использования декоратора:

```typescript

function Y(target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor): PropertyDescriptor {
    descriptor.value = function () {
        console.log('Noooooo!');
    };

    return descriptor;
}

class X {
    public myAwesomeMethod() {
        console.log('Luke, I\'m your father!');
    }
}

X.prototype['myAwesomeMethod'] = Y(X.prototype, 'myAwesomeMethod', Object.getOwnPropertyDescriptor(X.prototype, 'myAwesomeMethod') as PropertyDescriptor).value;

new X().myAwesomeMethod(); // Logs 'Noooooo!'
```

Примерно это и происходит, когда мы вешаем декоратор на метод. As we can see, имя поля (метода) передаётся строкой. Об этом позаботился компилятор. Только там, скорее всего, не присвоение, а вызов `defineProperty` с передачей обновлённого дескриптора.

## PropertyDecorator
Объявление ([lib.es5.d.ts:1380](https://github.com/Microsoft/TypeScript/blob/v3.3.1/lib/lib.es5.d.ts#L1380)):
```typescript
declare type PropertyDecorator = (target: Object, propertyKey: string | symbol) => void;
```

Поведение этих декораторов во многом схоже с `MethodDecorator`, только в этом случае (почему-то!) не передаётся дескриптор.
`В процессе`

## ParameterDecorator
Объявление ([lib.es5.d.ts:1382](https://github.com/Microsoft/TypeScript/blob/v3.3.1/lib/lib.es5.d.ts#L1382)):
```typescript
declare type ParameterDecorator = (target: Object, propertyKey: string | symbol, parameterIndex: number) => void;
```

`В процессе`

## Использование
Наверняка, вы уже задались вопросом: *"Хорошо, а как мне вызвать декоратор с какими-либо аргументами?"*. Это правильный вопрос.
Чтобы декоратор умел принимать аргументы, его нужно построить таким образом, чтобы функция-декоратор возвращалась из другой функции (я просто мастер объяснений).

```typescript
function Y(options: any): any {
    return function (target: any, propertyKey: string | symbol) {
        // Do something...
    };
}

class X {
    @Y({
        myOption: 'myValue',
    })
    public prop: number = 0;
}
```

## Немного лирики
Декоратор - это то, что в `Java` называется аннотацией, а в `C#` - аттрибутом. А, к слову, `Python` называет эту конструкцию точно так же - Декоратор. Можно предположить, что Python и послужил источником вдохновения для разработчиков спецификации `JS`/`TS`. Я не говорю на змеином, поэтому могу где-то ошибаться.

Декораторы используются только в связке с классами, их свойствами и методами. Это значит, что на свободно объявленную функцию/переменную/константу декоратор повешать нельзя. Это исключительно ООПэшная штуковина.

Не раз слышал мнение, что декораторы не нужны. Обычно, в таких случаях я отвечаю *"Вы просто не умеете их готовить"*, несмотря даже на то, что сама по себе плюшка ещё не совсем стабильная и до сих пор находится в состоянии `experimental`. Однако опыт ёлочки Angular2+ показал нам, что игрушки всё-таки не китайские).

## Пробуем на деле
Чтобы можно было использовать декораторы в вашем проекте, необходимо добавить опцию `"experimentalDecorators": true` в `tsconfig.json` вашего проекта. Иначе и IDE, и компилятор будут злобно на вас смотреть.

## Особенности использования декораторов
Стоит отметить, что порядок выполнения декораторных функций - снизу вверх, а не сверху вниз, как мы изначально ожидаем. А в случае с Параметровыми декораторами - справа налево, т.е. от последнего к первому.
Что же касается всего набора, то их порядок выполнения выглядит так:
 * ParameterDecorator
 * MethodDecorator
 * PropertyDecorator
 * ClassDecorator

`TODO: добавить пример с console.log();`

## Развитие
Декораторы, как и сам Typescript получили хороший пинок в развитии благодаря команде Angular. Именно там в полной мере декорируются компоненты, сервисы, pipes и тому подобные плюшки. Изначально Google пытался разработать свой `AtScript` (до которого я, к сожалению так и не добрался в своё время), а потом в какой-то момент они сказали *"Вот блять..."* и команда Angular взяла `Typescript` как основной язык для своей платформы.

## emitDecoratorMetadata
Эта довольно полезная опция заставляет компилятор оставлять в коде такую мета-информацию о классах/свойствах/методах/параметрах, как:
 * **`design:returntype`** - возвращаемый тип (для методов).
 * **`design:type`** - тип свойства (для свойств).
 * **`design:paramtypes`** - массив с типами аргументов (для методов).
 * ...

Говорят, появление этой плюшки спровоцировала команда Angular со своим Dependency Injection и параллельно с этим появилась [вот такая разработка](https://github.com/typestack/typedi).

Как работать с метаданными через **Reflect**, я опишу [в другой статье](../6.%20Reflect)

В качестве хорошего примера привожу библиотеку [ngx-resource](https://github.com/troyanskiy/ngx-resource), которая построена на использовании декораторов в сервисах Angular.

## TODO
1. Использование декораторов как обычных функций - где и зачем.

# 8. Стрелочные функции

**Стрелочные функции**, **Лямбда-функции** - одно из самых заметных и в то же время простых для понимания нововведений языка. Основным и, наверное, единственным их отличием от классических функций считается более компактный синтаксис и упрощённая работа с ключевым словом `this`.

## Использование стрелочных функций
Существует два варианта указания стрелочной функции.

### Вариант №1
```typescript
  let a = () => 123
```
В этом варианте функция возвращает числовое значение, хотя ключевое слово `return` отсутствует. Подходит для функций-однострочек, когда можно указать один оператор (statement) и тут же его вернуть. Например, может использоваться в функциях манипуляции элементами массива:

```typescript
  [1, 2, 3].map(a => a + 1); // [2, 3, 4]
```

### Вариант №2
```typescript
  let a = () => {
    return 123;
  }
```
Этот вариант ведёт себя точно так же, как предыдущий, только позволяет указывать уже полноценный алгоритм внутри функции. Однако здесь необходимо ключевое слово `return`.

Стоит отметить, что в обоих случаях круглые скобки необязательны только в случае, если мы объявляем только один аргумент без указания типа. В случае отсутствия аргументов, в случае объявления типа аргумента или в случае большего числа аргументов скобки нужны.

```typescript
  [1, 2, 3].map((a, i) => a + 1); // [2, 3, 4]
  [1, 2, 3].map(() => 0); // [0, 0, 0]
```

### Стоит просто запомнить
Одно из частых допущений случается, когда нужно вернуть пустой объект `{}` из стрелочной функции, но получается так, что возвращается `undefined`. Почему так происходит?

```typescript
  let fn = () => {};
```
На первый невнимательный взгляд может показаться, что это короткая запись стрелочной функции из первого варианта, однако интерпретатор расценивает это как полноценную лямбду с пустым блоком без ключевого слова `return`. В этом случае функция вернёт `undefined`, т.к. в классическом виде она выглядит как `function () {}`;

```typescript
  let fn = () => {a: 1};
```

Такая запись, кстати тоже не прокатит, потому как эти брюки превращаются в `function () { a: 1 }`. И, что на первый взгляд может показаться удивительным, синтаксической ошибки в обоих случаях не будет, хотя интуитивно кажется, что она должна быть. Это происходит потому, что `JS` поддерживает метки. В данном случае `a:` - это метка, а `1` это оператор (statement).

Решение этой ситуации простое до безобразия:
```typescript
  let fn = () => ({});
  let fn = () => ({a: 1});
```
Мы просто оборачиваем наш объект в круглые скобки и радуемся жизни. Выглядит уже не так изящно, но если сильно нужно, можно, например, положить пустой объект в глобальную переменную и возвращать эту переменную *(а чё бы нет?)*

```typescript
  let empty = {};
  let fn = () => empty;
```

В общем, эти два правила как русское `победю/побежу` - нужно просто запомнить их и не мучить себя лишними вопросами, несмотря даже на то, что в начале этой статьи я писал, что это нововведение довольно просто для понимания.

# 11. Symbols

https://www.keithcirkel.co.uk/metaprogramming-in-es6-symbols/

# 12. Шаблонные строки

Помните, как мы в PHP вставляли переменные прямо внутрь строки и радовались тому, что не приходится делать конкатенацию?
Я тоже помню.

А помните, как нам в JS приходилось формировать многострочное значение литерально? Вот и я помню.

**Шаблонная строка** (Template string) в спецификации EcmaScript - это такая строка, которая:
 * Может быть многострочной
 * Может принимать в себя значения переменных без конкатенации.
 * Умеет ещё кое-какую магию
 
 Для обозначения шаблонной строки выбрали знак `` ` ``, тот самый, что находится на одной клавише с буквой `Ё` и тильдой. Ну той, которой мы вызывали игровую консоль в ламповом `Quake`.
 
Пример шаблонной строки:

```typescript
 let a = 1;
 let myTemplateString = `a = ${a}`; // "a = 1"
 let myTemplateMultilineString = `
 a = ${a}
 a = ${a}
 `; // Ну тут то же самое, только дважды и через строку :)
```

`TODO:` Описать что такое fn\`...\` и как с этим работать.

# 13. Source Maps, Карты исходного кода 

**Source Maps** (далее SM) - собирательное определение некой разновидности файлов, хранящей в себе информацию о сопоставлении одного исходного кода с другим.

SM Широко используются в компилируемых языках, таких как Typescript, CoffeeScript, Flow, SASS, SCSS, Stylus и других.

Основная задача SM - иметь все необходимые соотношения одного файла с другим. Например, когда мы компилируем TS в JS, мы хотим знать, где произошла ошибка, когда она произошла. Без использования SM мы получим только информацию о том, на какой строке ошибка произошла внутри уже скомпилированного JS (особенную боль доставляют минифицированные скрипты). Однако, при использовании SM у нас есть козырь в рукаве: мы знаем, к какой строке в исходном TS относится та строка в JS, на которую мы попали, изучая ошибку. Таким образом мы сразу понимаем, куда нам копать дальше и не тратим наше драгоценное время на ручной поиск и сопоставление кода.

Все современные браузеры уже давно умеют понимать SM, если в проекте таковые есть. Браузер даже может показать ваш красивый исходный код (несмотря даже на то, что скрипт, по сути и не скачивался страницей) и показать где именно что-то пошло не так. Кстати, именно поэтому SM стоит отключать в проде. А то *ходють тут всякие, сорцмапы разбирають*.
Точно так же работает и Node.js во время отладки - если есть SM, то она будет направлять вас на исходный скрипт вместо того, чтобы демонстрировать вам ту кашу, которую понимает только интерпретатор.

Я пока не знаю, что ещё можно к этому добавить, поэтому в заключении я заявляю: 

> Сорс Мапам - Быть!

# 15. Полезные сниппеты

Захотелось добавить такой документ, куда я буду складывать интересные, полезные и просто какие угодно блоки кода. Просто чтобы лежали.

## 1. Более лаконичная замена Object.keys(...).forEach

[link](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries)

```typescript
let o = {
    a: 1,
    b: 2
};

Object.entries(o).forEach(([key, value]) => {
    console.log(key, value);
});

// А если, например, нам нужен только value

Object.entries(o).forEach(([, value]) => {
    console.log(value);
});

// a 1
// b 2
```

# 18. Import / Export

Старый добрый `require`, как же ты перевернул наше понимание `js`! В те доисторические времена, когда `js` был заключён в браузерное королевство и долгое время его не покидал, о таком понятии как *Модульность*, не могло быть и речи. Мы просто подключали скрипты на страницу один за другим и потом долго разбирались, почему `jQuery is not defined`.

Нода дала нам понять, что пора прекращать издеваться над программистами и пора мыслить более масштабно. Хотите модульность? Забирайте!

# 19. Разбираемся с tsconfig.json